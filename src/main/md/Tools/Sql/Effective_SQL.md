## Item-1: Every table should have Primary Key
* All tables should have a column (or set of columns) designated as a primary key.
  * Prefer single primary key instead of composite-key
* If you are concerned about duplicate values in a non-key column, you can define a unique index on the column to ensure integrity.
* Use as simple a key as possible, with values that do not need to be updated.
  * Use meaningless number values as primary key, so we don't need to update them forever
  * UID/Auto-Increment
  
## Item 2: Eliminate Redundant Storage of Data Items
* A goal of database normalization is the elimination of redundant data and minimizing resource use when processing data.
* By eliminating redundant data, you eliminate insert, update, and delete anomalies.
* By eliminating redundant data, you minimize the occurrence of inconsistent data.

## Item 3: Get Rid of Repeating Groups
1. Columns are expensive and rows are cheap
2. A red flag should be raised in your mind if the table design requires adding or removing columns to accommodate future data requirements with similar data.
3. UNION queries are useful for dealing with repeating groups.
4. A goal of database normalization is the elimination of repeating groups of data and minimizing the schema change.

## Item 4: Store Only One Property per Column
1. Column should be un-ambiguous
   1. Instead of column 'Name' have two column FirstName and LastName
2. If there is only one column for address
   1. You cannot easily search for street name, city, state/province, or postal code.
3. Correct table design assigns each individual property to its own column, because when a column contains multiple properties, searching and grouping become difficult if not impossible.

## Item 5: Understand Why Storing Calculated Data Is Usually a Bad Idea

1. Many systems let you define calculated columns when you define your table, but you need to be aware of the performance implications, particularly when using nondeterministic expressions or functions.
2. Calculated columns cause additional overhead in your database system, so use them only when the benefits outweigh the costs.
3. You cannot build index on the table that is generated by function calculation of another table
   1. The function depends on data from another table, it is nondeterministic
4. Using views to define calculations is often a desirable alternative to actually storing calculations on a table for cases where indexing does not apply.

## Item 6: Define Foreign Keys to Protect Referential Integrity

```sql
         ALTER TABLE Orders
           ADD CONSTRAINT Orders_FK99
           FOREIGN KEY (CustomerID)
           REFERENCES Customers (CustomerID);
 ```
* In Customer Table, - ON DELETE CASCADE (to Orders)
* on some db, defining a referential integrity constraint automatically creates an index on the foreign key column(s), so there may be an added performance benefit when performing a join
* it is good practice creating an index to optimize constraint checking. (on db that doesn't automatically create index)



## String concatenation
1. Concat(Concat(param1, Param2), "Param3")
2. Param1 || Param2 || Param3