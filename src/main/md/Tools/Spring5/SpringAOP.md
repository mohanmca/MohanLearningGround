## AOP Notes

```pre
Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by providing another way of thinking about program structure.

The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect.

Aspects enable the modularization of concerns (such as transaction management) that cut across multiple types and objects. (Such concerns are often termed “crosscutting” concerns in AOP literature.)

One of the key components of Spring is the AOP framework.

cross-cutting concern is a functionality that is tangled with business code, which usually cannot be separated from the business logic. They are mingled with the business code, heavily coupled with the functionality that might be affected if they fail.

AOP is a programming type that can help reduce code scattering and tangling by modularizing cross-cutting concerns.

The business or base code is not actually changed; you can imagine aspects as plugins. They modify the behavior, not the actual implementation

The most common cross-cutting concerns : Transaction, Logging, Security, Monitoring, Caching, Caching, Internationalization, Error detection and correction, Memory management, Performance monitoring, Synchronization, Auditing

Cross-cutting concerns cause code scattering and tangling

AOP is a type of programming that aims to help with separation of cross-cutting concerns to increase modularity; it implies declaring an aspect class that will alter the behavior of base code, by applying advices to specific join points, specified by pointcuts

AOP is a complement of OOP (Object Oriented Programming) and they can be used together to write powerful applications, because both provide different ways of structuring your code.

Spring Security, makes use of AOP to control access to sensitive data.

Spring transactions, makes use of Spring AOP to transparently manage transactions

AOP complements Spring IoC to provide a very capable middleware solution

Aspects can be applied only to Spring Beans.

The original library that provided components for creating aspects is named AspectJ. It was developed by the Xerox PARC company and released in 1995. It defined a standard for AOP because of its simplicity and usability. The language syntax used to define aspects was similar to Java and allowed developers to define special constructs called aspects. The aspects developed in AspectJ are processed at compile time, so they directly affect the generated bytecode.

Only public Join Points can be advised

If a method in the proxy calls another method in the proxy, and both match the pointcut expression of an advice, the advice will be executed only for the first method. This is the proxy’s nature: it executes the extra behavior only when the caller calls the target method.

Even if Spring AOP is not set to use CGLIB proxies, if a Join Point is in a class that does not implement an interface, Spring AOP will try to create a CGLIB proxy.

Spring provides simple and powerful ways of writing custom aspects by using either a schema-based approach or the @AspectJ annotation style.

In Spring AOP, aspects are implemented by using regular classes (the schema-based approach <aop:aspect id="myAspect" ref="aBean"> ) or regular classes annotated with the @Aspect annotation (the @AspectJ style).

Join point: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.

Advice: Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice.

Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut

Introduction: Declaring additional methods or fields on behalf of a type.

Target object: An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.

AOP proxy: An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.

Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.

Spring AOP includes the following types of advice:

Before advice: Advice that runs before a join point but that does not have the ability to prevent execution flow proceeding to the join point (unless it throws an exception).

After returning advice: Advice to be run after a join point completes normally (for example, if a method returns without throwing an exception).

After throwing advice: Advice to be executed if a method exits by throwing an exception.

After (finally) advice: Advice to be executed regardless of the means by which a join point exits (normal or exceptional return).

Around advice: Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or throwing an exception.

The concept of join points matched by pointcuts is the key to AOP

Spring AOP currently supports only method execution join points (advising the execution of methods on Spring beans).

If you need to advise field access and update join points, consider a language such as AspectJ.

The aim of AOP is to provide a close integration between AOP implementation and Spring IoC, to help solve common problems in enterprise applications.

Aspects are configured by using normal bean definition syntax (although this allows powerful “auto-proxying” capabilities).

You have the choice of AspectJ, Spring AOP, or both. You also have the choice of either the @AspectJ annotation-style approach or the Spring XML configuration-style approach.

Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.

Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. By default, CGLIB is used if a business object does not implement an interface

It is important to grasp the fact that Spring AOP is proxy-based.

Code tangling and code scattering are two issues that come together when base code needs to be executed under certain conditions.

Code tangling means that the same component is injected into many others, thus leading to significant dependencies coupling components together. (coupling)

Code scattering means duplication, because you can do the same thing in only one way.(duplication DRY)

@AspectJ refers to a style of declaring aspects as regular Java classes annotated with annotations.

To use @AspectJ aspects in a Spring configuration, you need to enable Spring support for configuring Spring AOP based on @AspectJ aspects and auto-proxying beans based on whether or not they are advised by those aspects. By auto-proxying, we mean that, if Spring determines that a bean is advised by one or more aspects, it automatically generates a proxy for that bean to intercept method invocations and ensures that advice is executed as needed.

he @AspectJ support can be enabled with XML- or Java-style configuration. In either case, you also need to ensure that AspectJ’s aspectjweaver.jar library is on the classpath of your application (version 1.8 or later). This library is available in thelib directory of an AspectJ distribution or from the Maven Central repository.

Enabling @AspectJ Support with Java Configuration @EnableAspectJAutoProxy

Enabling @AspectJ Support with XML Configuration <aop:aspectj-autoproxy/>

Aspects (classes annotated with @Aspect) can have methods and fields, the same as any other class. They can also contain pointcut, advice, and introduction (inter-type) declarations.

Note that the @Aspect annotation is not sufficient for autodetection in the classpath. For that purpose, you need to add a separate @Component annotation.

In Spring AOP, aspects themselves cannot be the targets of advice from other aspects. The @Aspect annotation on a class marks it as an aspect and, hence, excludes it from auto-proxying.

Pointcuts determine join points of interest and thus enable us to control when advice executes.

Declaring a Pointcut @Pointcut("execution(* transfer(..))")

Supported Pointcut Designators PCD (execution, within, this, target, args, @target, @args, @within, @annotation)

Due to the proxy-based nature of Spring’s AOP framework, calls within the target object are, by definition, not intercepted. For JDK proxies, only public interface method calls on the proxy can be intercepted. With CGLIB, public and protected method calls on the proxy are intercepted (and even package-visible methods, if necessary). However, common interactions through proxies should always be designed through public signatures.

If your interception needs include method calls or even constructors within the target class, consider the use of Spring-driven native AspectJ weaving instead of Spring’s proxy-based AOP framework. This constitutes a different mode of AOP usage with different characteristics, so be sure to make yourself familiar with weaving before making a decision.

Spring AOP also supports an additional PCD named bean. This PCD lets you limit the matching of join points to a particular named Spring bean or to a set of named Spring beans (when using wildcards). The bean PCD has the following form: bean(idOrNameOfBean)

The format of an execution expression follows: execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
throws-pattern?)

If the target object to be proxied implements at least one interface, a JDK dynamic proxy is used. All of the interfaces implemented by the target type are proxied. If the target object does not implement any interfaces, a CGLIB proxy is created.

To force the use of CGLIB proxies, set the value of the proxy-target-class attribute of the <aop:config> element to true, as follows: <aop:config proxy-target-class="true"> ..</aop:config>

To force CGLIB proxying when you use the @AspectJ auto-proxy support, set the proxy-target-class attribute of the <aop:aspectj-autoproxy> element to true, as follows: <aop:aspectj-autoproxy proxy-target-class="true"/>

Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ

If you only need to advise the execution of operations on Spring beans, Spring AOP is the right choice. If you need to advise objects not managed by the Spring container (such as domain objects, typically), you need to use AspectJ.

You also need to use AspectJ if you wish to advise join points other than simple method executions (for example, field get or set join points and so on).

If you have chosen to use Spring AOP, you have a choice of @AspectJ or XML style. There are various tradeoffs to consider.

With the XML style, it is arguably clearer from your configuration which aspects are present in the system.

The XML style has two disadvantages. First, it does not fully encapsulate the implementation of the requirement it addresses in a single place.

The DRY principle says that there should be a single, unambiguous, authoritative representation of any piece of knowledge within a system.

The @AspectJ style supports additional instantiation models and richer pointcut composition. It has the advantage of keeping the aspect as a modular unit. It also has the advantage that the @AspectJ aspects can be understood (and thus consumed) both by Spring AOP and by AspectJ. So, if you later decide you need the capabilities of AspectJ to implement additional requirements, you can easily migrate to a classic AspectJ setup. On balance, the Spring team prefers the @AspectJ style for custom aspects beyond simple configuration of enterprise services.

The only supported instantiation model for schema-defined aspects is the singleton model. Other instantiation models may be supported in future releases.

Within your Spring configurations, all aspect and advisor elements must be placed within an <aop:config> element (you can have more than one <aop:config> element in an application context configuration). An <aop:config> element can contain pointcut, advisor, and aspect elements (note that these must be declared in that order).

When you use the schema support, an aspect is a regular Java object defined as a bean in your Spring application context. The state and behavior are captured in the fields and methods of the object, and the pointcut and advice information are captured in the XML. <aop:aspect id="myAspect" ref="aBean">

You can declare a named pointcut inside an <aop:config> element, letting the pointcut definition be shared across several aspects and advisors. <aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/>

another way of defining the above pointcut would be as follows:<aop:pointcut id="businessService" expression="com.xyz.myapp.SystemArchitecture.businessService()"/>

Declaring Advice <aop:before pointcut-ref="dataAccessOperation" method="doAccessCheck"/>

Declaring Advice <aop:before pointcut="execution(* com.xyz.myapp.dao.*.*(..))" method="doAccessCheck"/>

What is the XML equivalent of @EnableAspectJAutoProxy

The template that a pointcut expression follows can be defined as follows: execution( [Modifiers] [ReturnType] [FullClassName].[MethodName] ([Arguments]) throws [ExceptionType])

The expression can contain wildcards like + and * and can be made of multiple expressions concatenated by boolean operators such as &&, ||, etc. The * wildcard replaces any group of characters; the + wildcard is used to specify that the method to advise can also be found in subclasses identified by [FullClassName] criteria.

There is also a list of designators that can be used to define the reach of the pointcut; for example, the within(...) designator can be used to limit the pointcut to a package

Spring AOP functionality is based on AspectJ, which is why when Spring AOP libraries are used, aspectjweaver and aspectjrt must be added to the application classpath.

Spring AOP cannot advise objects that are not managed by the Spring container.

Spring AOP uses dynamic proxies for aspect weaving, so the bytecode of the target objects is not affected in any way.

Spring IoC can be used to write software applications, and for business applications that require the use of cross-cutting concerns, using Spring AOP is a must.

Aspect: a class containing code specific to a cross-cutting concern. A class declaration is recognized in Spring as an aspect if it is annotated with the @Aspect annotation.

Weaving: a synonym for this word is interlacing, but in software, the synonym is linking, and it refers to aspects being combined with other types of objects to create an advised object.

Join point: a point during the execution of a program. In Spring AOP, a joint point is always a method execution. Basically, the join point marks the execution point where aspect behavior and base behavior join.

Target object: object to which the aspect applies.

Target method: the advised method.

Advice: action taken by an aspect at a join point. In Spring AOP there are multiple advice types: @Before, @AfterReturning, @AfterThrowing, @After, @Around,

Introduction: declaring additional methods, fields, interfaces being implemented, annotations on behalf of another type. Spring AOP allows this using a suite of AspectJ @Declare* annotations that are part of the aspectjrt library.

AOP proxy: the object created by AOP to implement the aspect contracts. In Spring, proxy objects can be JDK dynamic proxies or CGLIB proxies. By default, the proxy objects will be JDK dynamic proxies, and the object being proxied must implement an interface, that will also be implemented by the proxy object. But a library like CGLIB can be used to create proxies by subclassing too, so an interface is not needed.

Pointcut: a predicate used to identify join points. Advice definitions are associated with a pointcut expression and the advice will execute on any join point matching the pointcut expression. Pointcut expressions are defined using AspectJ Pointcut Expression Language.1 Pointcut expressions can be defined as arguments for Advice annotations or as arguments for the @Pointcut annotation.

The class containing the aspect definition must be declared as a bean. (@Component + @Aspect + @EnableAspectJAutoProxy + Advice(pointcut) )

The JDK proxies are created at runtime using JDK Reflection API, and reflection is known to affect performance.

You can disable aspects support by commenting the @EnableAspectJAutoProxy annotation, and Spring will just ignore the Aspect annotation.

If the CGLIB library is to be added to the application classpath, Spring must be told that we want subclass-based proxies by modifying the aspect enabling annotation to @EnableAspectJAutoProxy(proxy TargetClass = true).

The proxies generated with CGLIB are called subclass-based, and one of their advantages is that they can override methods optionally. They use specialized interceptors to call methods, and this can actually improve performance.

So basically, in order to use aspects in a Spring application you need the following:

spring-aop as a dependency

declare an @Aspect class and declare it as a bean as well (using @Component or @Bean or XML typical bean declaration element)

declare an advice method annotated with a typical advice annotation (@Before, @After, etc.) and associate it to a pointcut expression

enable aspects support by annotating a configuration class with @EnableAspectJAutoProxy

(optional) add CGLIB as a dependency and enable aspects support using subclassed proxies by annotating a configuration class with @EnableAspectJAutoProxy(proxyTargetClass = true)

<!-- Configure Aspect support --> <aop:aspectj-autoproxy> <aop:include name="userRepoMonitor"/> </aop:aspectj-autoproxy>.

<!-- Configure advice --> <aop:config> <aop:aspect ref="userRepoMonitor"> <aop:before pointcut="execution(public com.ps.repos.˙JdbcTemplateUserRepo+.findById(..))" method="beforeFindById" /> </aop:aspect> </aop:config>

To configure the use of subclass-based proxies, the <aop:aspectj-autoproxy../> must have the proxy-target-class attribute set to true.

And by using the @annotation() designator, only methods annotated with a specific annotation can be taken into consideration: execution(public (public * com.ps.service.*.*Service+.*(..) && @annotation(org.springframework.security.access.annotation.Secured))

The template that a pointcut expression follows can be defined as follows: execution( [Modifiers] [ReturnType] [FullClassName].[MethodName] ([Arguments]) throws [ExceptionType])

The [ReturnType] is mandatory. If the return type is not a criterion, just use *.

The [Modifers] is not mandatory and if not specified defaults to public.

The [MethodName] is not mandatory, meaning no exception will be thrown at boot time.

The [Arguments] is mandatory . the arguments are not a criterion just use (..) which will match a method with 0 or many arguments. . (*) mean one argument, and () means no arguments.



A reference to the target object can be obtained by calling joinPoint.getTarget().

From the joinpoint perspective, Spring AOP supports only pointcuts matching on the execution of public nonstatic methods

AspectJ is a fully featured AOP implementation that uses a weaving process (either compile-time or loadtime weaving) to introduce aspects into your code

By default, AspectJ aspects are singletons, meaning you get a single instance per class loader. The problem Spring faces with any AspectJ aspect is that it cannot create the aspect instance, as this is already handled by AspectJ itself.

Notice the @EnableAspectJAutoProxy annotation. It is the equivalent of <aop:aspectj-autoproxy/> and also has an attribute called proxyTargetClass that is analogous to the proxy-target-class attribute

So far, we have discussed three ways of declaring Spring AOP configuration, including the ProxyFactoryBean, the aop namespace, and @AspectJ-style annotations. We believe you will agree that the aop namespace is much simpler than ProxyFactoryBean. So, the general question is, do you use the aop namespace or @AspectJ-style annotations?

If your Spring application is XML configuration–based, using the aop namespace approach is a natural choice because it keeps the AOP and DI configuration styles consistent.

On the other hand, if your application is mainly annotation based, use the @AspectJ annotation

Moreover, there are some other differences between the aop namespace and @AspectJ annotation approaches.

The pointcut expression syntax has some minor differences (for example, in the previous discussions, we need to use and in the aop namespace, but && in @AspectJ annotation).

The aop namespace approach supports only the “singleton” aspect instantiation model.

In the aop namespace, you can’t “combine” multiple pointcut expressions. In the example using @AspectJ, we can combine the two pointcut definitions (that is, singExecution(value) && isJohn()) in the before and around advice. When using the aop namespace and you need to create a new pointcut expression that combines the matching conditions, you need to use the ComposablePointcut class.

When using declarative configuration of Spring AOP, three options exist.

Using ProxyFactoryBean: In Spring AOP, ProxyFactoryBean provides a declarative way to configure Spring’s ApplicationContext (and hence the underlying BeanFactory) when creating AOP proxies based on defined Spring beans.

Using the Spring aop namespace: Introduced in Spring 2.0, the aop namespace provides a simplified way (when compared to ProxyFactoryBean) to define aspects and their DI requirements in Spring applications. However, the aop namespace also uses ProxyFactoryBean behind the scenes.

Using @AspectJ-style annotations: Besides the XML-based aop namespace, you can use the @AspectJ-style annotations within your classes for configuring Spring AOP. Although the syntax it uses is based on AspectJ and you need to include some AspectJ libraries when using this option, Spring still uses the proxy mechanism (that is, creates proxied objects for the targets) when bootstrapping ApplicationContext

When using the aop namespace or the @AspectJ style, there are two types of after advice. The after-returning advice (using the <aop:after-returning> tag) applies only when the target method is completed normally. Another one is the after advice (using the <aop:after> tag), which takes place whether the method was completed normally or the method runs into an error and an exception is thrown. If you need advice that executes regardless of the execution result of the target method, you should use after advice.

Introductions are one of the most powerful features of Spring AOP; they allow you not only to extend the functionality of existing methods but to extend the set of interfaces and object implementations dynamically. Using introductions is the perfect way to implement crosscutting logic that your application interacts with through well-defined interfaces. In general, this is the kind of logic that you want to apply declaratively rather than programmatically.

Obviously, because introductions work via proxies, they add a certain amount of overhead. All methods on the proxy are considered advised since pointcuts cannot be used in conjunction with introductions. However, in the case of many of the services that you can implement by using introductions such as the object modification check, this performance overhead is a small price to pay for the reduction in code required to implement the service, as well as the increase in stability and maintainability that comes from fully centralizing the service logic.

As we mentioned earlier, there are two distinct types of AOP: static and dynamic. The difference between them is really the point at which the weaving process occurs and how this process is achieved.

Static AOP : In static AOP, the weaving process forms another step in the build process for an application. In Java terms, you achieve the weaving process in a static AOP implementation by modifying the actual bytecode of your application, changing and extending the application code as necessary. This is a well-performing way of achieving the weaving process because the end result is just Java bytecode, and you do not perform any special tricks at runtime to determine when advice should be executed. The drawback of this mechanism is that any modifications you make to the aspects, even if you simply want to add another joinpoint, require you to recompile the entire application. AspectJ’s compile-time weaving is an excellent example of a static AOP implementation

Dynamic AOP : Dynamic AOP implementations, such as Spring AOP, differ from static AOP implementations in that the weaving process is performed dynamically at runtime. How this is achieved is implementation-dependent, but as you will see, Spring’s approach is to create proxies for all advised objects, allowing for advice to be invoked as required. The drawback of dynamic AOP is that, typically, it does not perform as well as static AOP, but the performance is steadily increasing. The major benefit of dynamic AOP implementations is the ease with which you can modify the entire aspect set of an application without needing to recompile the main application code.



Aspects by default are singletons
```


* [Spring AOP](https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/spring-framework-reference/core.html#aop)