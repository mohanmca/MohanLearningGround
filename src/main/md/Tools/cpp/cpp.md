## Where to run Cpp
1. [https://godbolt.org/](https://godbolt.org/)
2. [Hacking CPP](https://hackingcpp.com/cpp/cheat_sheets.html)
3. [CPP-Cling](https://root.cern/cling/)

## Missing lectures
1. [https://missing.csail.mit.edu/](https://missing.csail.mit.edu/2019/)
1. [Software Carpentry](https://software-carpentry.org/lessons/)

## CPP Lectures
1. [C++ University Lectures and notes](https://www.ipb.uni-bonn.de/teaching/cpp-2020/lectures/index.html)
2. [C++ Bonn Lectures and combined notes](https://github.com/mohanmca/MohanLearningGround/blob/master/src/main/resources/uni-bonn-de-teaching-modern-cpp-2020-lecture.pdf)
3. [Systems Programming in C++](https://db.in.tum.de/teaching/ss23/c++praktikum/slides/lecture.pdf?lang=en)
4. [Systems Programming in C++- Combined notes](https://github.com/mohanmca/MohanLearningGround/blob/master/src/main/resources/SystemsProgramminginC%2B%2BMunich.pdf)
5. [Systems Programming in C++ with video recordings](https://db.in.tum.de/teaching/ss21/c++praktikum/index.shtml?lang=en)

## CPP Test
1. [Linked In Assesment for C++](https://linkedin-faq.github.io/skill-assessments-quizzes/quiz/c%2B%2B)
1. [google.com/edu/c++ quiz](https://developers.google.com/edu/c++/quiz)
2. [CPP Standard Quiz](https://cppquiz.org/)
3. [C++ Chapter wise test](https://test.sanfoundry.com/cplusplus-programming-tests/)
4. [C++ Test](https://picake314.github.io/cppishard/#/)
5. [CPP Quizes](https://www.reddit.com/r/cpp/comments/fcqruv/c_quizzes/)
6. [Edabit](https://edabit.com/)
7. [C++ Chapterwise quiz](https://www.cprogramming.com/quiz/)
8. [Hard to crack C++ Quiz](https://pvs-studio.com/en/blog/quest/kushnirenko_quiz/)

## CPP Courses
1. [Modern-CPP-Programming](https://github.com/federico-busato/Modern-CPP-Programming?tab=readme-ov-file)
1. [Modern CPP overview](https://oleksandrkvl.github.io/2021/04/02/cpp-20-overview.html)
1. [ISO Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero)
1. [C++ FAQ](https://yosefk.com/c++fqa/)
1. [Fastest Modern CPP book](https://changkun.de/modern-cpp/pdf/modern-cpp-tutorial-en-us.pdf)

## CPP - Design Patterns
1. [Singleton](https://refactoring.guru/design-patterns/singleton/cpp/example)
2. [Strategy](https://refactoring.guru/design-patterns/strategy/cpp/example)
3. [Iterator](https://refactoring.guru/design-patterns/iterator/cpp/example)
4. [Template method](https://refactoring.guru/design-patterns/template-method/cpp/example)
5. [Prototype](https://refactoring.guru/design-patterns/prototype/cpp/example)

## Mastering CPP
1. [Entire game engine coded live](https://handmadehero.org/)
2. [Everything about CPP hacking](https://hackingcpp.com/cpp/blogs.html)

## [Low latency C++ Exchange Thread](https://news.ycombinator.com/item?id=40908273)
1. [Review comments about queue and code](https://news.ycombinator.com/item?id=40908273)

## CPP - Todo
1. CPP - Iterator Invalidation Rules


## What is stack-frame? How is stack used during function invocation?
1. Use this as prompt: In C++, when local variables are stored on the stack within a function, how are they accessed during the function's execution? Do the variables require repeated push and pop operations, or is there a different mechanism used to access them?

## What is hello world program in CPP?
```c++
#include <iostream>

using namespace std;
int main(void) {
  cout << "It's working\n" << endl;
}
```

## Real Errors
1. [Error: pure virtual method called - terminate called without an active exception - Aborted](https://stackoverflow.com/questions/63261761/qt-pure-virtual-method-called-terminate-called-without-an-active-exception)

## Stack, Heap and Segments
1. Stack
   1. Every function call has function-call-frame
   2. Function call frame has all local the variables of a function and arguments of the function
   3. If there is pointer variable, pointer variable may be in local stack, but its target address (memory) may be in heap
2. Heap
   2. Dynamic allocation
   3. calloc / malloc
3. Data segment
   1. global and static variable
4. Code segment  or Text segment
   1. Machine code segment
   2. Also known as text segment

## "=Delete" usage? How to avoid  double deletion or resource leaks?

1. Syntax is used to explicitly disallow certain functions that would otherwise be automatically generated by the compiler.
2. Copy constructor and copy assignment operator are declared as deleted (few times)?
3. This means that the compiler will not allow the ClassName objects to be copied. This is typically done for objects that manage resources (like memory or file handles), where the default shallow copy behavior would lead to problems (like double deletion or resource leaks).
4. By deleting these functions, the author of the class is ensuring that every ClassName object has exclusive ownership over its buffer (m_buffer). This is a common technique in C++ to prevent resource management bugs.

## Why few classes might be using calloc instead of new byte[]?
1. Initialization: calloc initializes the allocated memory to zero, whereas new byte[] does not. This can be useful if you want to ensure all bytes in your buffer are initially zero.
2. Compatibility: calloc is a function from the C standard library. If ClassNames is designed to be compatible with C, using calloc would make sense
3. Error Handling: calloc returns a null pointer if it fails to allocate memory, which can be checked against. In contrast, new byte[] throws an exception if memory allocation fails. Depending on how error handling is done in the rest of the code, one might be preferable over the other.

## What is lvalue and rvalue
* lvalue a lot of time, it is on left side of equal sign (or) value passed to function
  * 10 = i; compiler error, expression must be a modifiable lvalue (here i is lvalue, if int i = 10;
  * int a = i; both a and i are lvalue; considering above line is int i =10;
  * You can't take lvalue reference from rvalue
  * SetValue(int value) //function takes lvalue
  * SetValue(int& value) //function takes lvalue reference
* rvalue a lot of time, it is on right side of equal sign (or) value returned by function
  * rvalue could be literal, int i = 10; 10
  * rvalue could be result of a function (value returned by function)
  * You can't take lvalue reference from rvalue
  * SetValue(int&& value) //function takes rvalue reference
```cpp
int i=10;
```

```cpp
int& GetLValue() {
  static int value = 10;
  return value;
}

int main() {
 GetLValue() = 5; //this would work, due to Lvalue Reference
}
```

## What is the difference between reference and pointer
1. Reference is similar to pointer, but we don't need prefix * (such as *p)
2. Reference can't be made to refer to a different object after its initialization
3. References are useful to specify function arguments
4. “Functions taking const references are very common.” (good practice)
5. We can't have uninitialized reference

## Assignment
1. = assignment operation is simple copy operation in C++ (not in java)
2. “After x=y, we have x==y for every built-in type and well-designed user-defined type (Chapter 2) that offers = (assignment) and == (equality comparison).”

## Initialization
1. For almost all the type, effect of reading from or writing to an uninitialized variable in undefined
2. int& r; //Error: Uninitialized reference
3. “The basic semantics of argument passing and function value return are that of initialization”

## What is nullptr?
1. It is singleton
2. When pointer needs to dereference from the object that is pointing to

## Coverting C++ into a program
1. g++ -S main.cpp -o main.s (Produces human readable assembly code)
2. g++ -c main.cpp -o main.o (Produces object file)
3. g++ main.cpp -o main (Produces executable using compiles, assembles and links)
  1. Linking the library is done by the linker, which is called by the compiler.
  1. During linking the linker will resolve the symbols in the object files and libraries.
6. g++ --std=c++11 main.cpp -o main (Use C++11 standard)

## Data types
1. 3E8 == 300,000,000 = 3 x 10^8
2. Plancks constant - 6.62607E-34
3. Divide by zero might cause - compilation error, runtime error or some message at runtime.
   4. Division by 0 invokes undefined behaviour
4. Operators of larger (higher) priority perform their operations before the operators with lower priority.
5. Binding, C++ mostly left binding.

## Why sometime we declare variable with uint32_t instead of int?
1. Guaranteed size of 32 bits
2. Range clarification
3. Portability
4. Explicit intent (avoid signedness and overflow)
5. Adherence to moder practice (MISRA & CERT-C)

## What is simplest C++ program that processes command line String

```c++
#include <iostream>
#include <vector>
#include <string>

int main(int argc, char** argv) {
    std::vector<std::string> arguments;

    for (int i = 0; i < argc; ++i) {
        arguments.push_back(argv[i]);
    }

    for (const std::string& arg : arguments) {
        std::cout << arg << std::endl;
    }

    return 0;
}
```

## Tidbits about C++
1. in C++, all strings are considered as arrays
2. Char is just subset of number, that would be treated as alphabets. ASCII mapping.
3. In ASCII, --- space is 32, A = 65, A+___ (space) = a, 97
4. \0 = nul char, represent no-character
5. '\47' = Octal chracter, 39 decimal == '\'', '\x27'
6. you can mix and match int with char and perform arithmatic operation
7.   'a' - ' ', a - 32, 'A' + 32, 'A' + ' '
8. 'uint64_t' {aka 'long unsigned int'}

## Stream has two responsible
1. Converting any types into human readable
2. Transfer them to output device
3. You can use *manipulator* along with stream to transform values
4. hex is one manipulator, changes the output streams properties called *basefield*
5. hex, dec, oct are the other manipulators
6. Manipulators
7. endl is a manipulator

## Manipulator Examples
```C++
int main() {
    int byte = 255;
    cout << hex << byte << endl;
    cout << byte << endl << dec << byte<<endl;
}
```

```c++
#include <iostream>
#include <iomanip>
using namespace std;
 
int main()
{
    float PI = 3.14;
    int num = 100;
    cout << "Entering a new line." << endl;
    cout << setw(10) << "Output" << endl;
    cout << setprecision(10) << PI << endl;
    cout << setbase(16) << num << endl; //sets base to 16
}
```

* The sign << is called the insertion operator.
* The sign >> is called the extraction operator.
* cout keyword is used to print.
* cin keyword is used to take input at run time.

## Why to use curly-brace-delimiter-initializer-list
1. It saves from coversions that lose information
2. int i2 {7.8} -- would compilation failure, whereas int i2=7.8; would work


## datatype modifers to reduce memory or increase width of the number
1. modifiers such as long/short/unsigned would either decrease the memory usage of primitivie-data-type such as int, or increase to suit larger number
2. long int == long, short int = short, unsigned int = unsigned
3. char == [-128 to 127], unsigned char == 0 255
4. long can be declared in 3 days
	5. literal value goes beyond the acceptable range of type int; 98l or 987L (suffix L)
 6. short modifer never works with float, but `long float` would work, 'long float == double'
 7. double can store larger number and with better accuracy
 8. float would store 8 digits after decimal point for accuracy, double would store 15-17 accuracy
 9. numerical anomaly - is unavoidable

## boolean
1. bool developer_is_hubgry =  true
2. boolean is like int, but it uses only 8-bit (1 - byte)
3. zero == false, non-zero == true

## empty for-loop
1. when data missing, c++ assumes 1 is there, hence below is infinite;
```c++
for( ; ; ) {
  /* the body goes here */ 
}
```

## Logical opertion on it
```
C++ also uses - two's complement numbers
i: 00000000000000000000000000001111
j: 00000000000000000000000000010110
int log = i && j;
log:00000000000000000000000000000001
int bit = i & j;
bit:00000000000000000000000000000110
```

## Unsigned CPP (double the range)
```
unsigned int myUnsignedVariable = 0;
myUnsignedVariable--;  // Decrementing from 0
It will wrap around, and the result will be the maximum value representable by an unsigned int. For a 32-bit unsigned int, the maximum value is 4294967295.
```

## Switch case
1. Missing break is big mistake
2. Value after the case must not be an expression containing variables or any other entities whose values aren't known at compilation time;
```
switch(i) {
    case 1: cout << "Only one?" << endl; break;
    case 2: cout << "I want more" << endl; break;
    case 3: 
    case 4: cout << "OK and work for 3 Or 4" << endl; break;
    default: cout << "Don't care"  << endl;
}
```

## What is CRTP?

```cpp
template<class Z> class Y {};
class X : public Y<X> {};
```

## What is shared smart pointer and how to create?
```
In this example, std::make_shared<MyClass>(10) creates a new instance of MyClass with 10 as the argument to its constructor, 
and returns a std::shared_ptr that owns the newly created object. 
The std::shared_ptr will automatically delete the object when there are no more std::shared_ptr objects pointing to it.
```
```cpp
#include <memory>

class MyClass {
public:
    MyClass(int val) : value(val) {}
    int value;
};

int main() {
    std::shared_ptr<MyClass> ptr = std::make_shared<MyClass>(10);
    return 0;
}
```


## Source of bugs
1. implicit narrowing conversion
2. Union
3. Array Decay

## Many more
1. int vector[5] = {0,1,2,3,4}; //array with initializaion
2. If you provide fewer values than the size of an array, like this, nothing bad will happen.
  3. he compiler determines that those elements you didn‘t specify any value to should be set to 0.
  4. int vector[5] = {0,1,2};
  5. int vector[] = {0,1,2,3,4,5,6}; //this is legal
  6. int chessboard[8][8];
4. fill first 100 slots with -1 for an array - ```std::fill_n(array, 100, -1);```

## usual_arithmetic_conversions
[Usual arithmetic coversion](https://en.cppreference.com/w/cpp/language/usual_arithmetic_conversions)

## Pure function and const, consteval and constexpr
1. const at runtime, wheras constexpr is during compiletime, const-expr places value in read-only memory
2. Function can also be declared with constexpr (it has to evaluate during compile time, otherwise it would error)
  1. ```“constexpr double square(double x) { return x*x; }”```
  1. ```“consteval double square(double x) { return x*x; }”``` //function that needs to eval'ed only during compilation time
3.  *Pure Function*
  3.1. Function declared with constexpr and consteval are C++ version of "pure function", they cannot have side effects
  3.2. Pure function can only operate within the arguments given, they can't modify non-local variable
4. size of the array must be constant expression

## Auto for-loop

```cpp
int main() {
for(const auto x: {1,2,3,4,5})
  cout << x << "\n";
}

int main() {
for(const auto& x: {1,2,3,4,5})
  cout << x << "\n";
}
```

## If statement introduced varaible, and check/test
1. Variable is available in both the block (if and else)
2. We can use shortcut when things are not zero
```cpp
if (auto n = v.size(); n!=0) {
	// ... we get here if n!=0 ...
}
if (auto n = v.size()) {
	// ... we get here if n!=0 ...
}
```

## What are disadvantages of header.h include file mechanics?

There are four disadvantages

1. Compilation time: If you #include header.h in 101 translation units, the text of header.h will be processed by the compiler 101 times.
2. Order dependencies: If we #include header1.h before header2.h the declarations and macros (§19.3.2.1) in header1.h might affect the meaning of the code in header2.h. If instead you #include header2.h before header1.h, it is header2.h that might affect the code in header1.h.
3. Inconsistencies: Defining an entity, such as a type or a function, in one file and then defining it slightly differently in another file, can lead to crashes or subtle errors. This can happen if we – accidentally or deliberately – declare an entity separately in two source files, rather than putting it in a header, or through order dependencies between different header files.
4. Transitivity: All code that is needed to express a declaration in a header file must be present in that header file. This leads to massive code bloat as header files #include other headers and this results in the user of a header file – accidentially or deliberately – becoming dependent on such implementation details.”

## What are the advantages of Modules
1. A module is compiled once only (rather than in each translation unit in which it is used).
2. Two modules can be imported in either order without changing their meaning.
3. If you import or #include something into a module, users of your module do not implicitly gain access to (and are not bothered by) that: import is not transitive.

## Role of using directive

1. A using-declaration makes a name from a namespace usable as if it were declared in the scope in which it appears. After using std::swap, it is exactly as if swap had been declared in current scope.
2. A using-directive makes unqualified names from the named namespace accessible from the scope in which we placed the directive. 
3. So after the using-directive for std, we can simply write cout rather than std::cout.
4. 
```cpp
export module vector_printer;
import std;
using namespace std;

export
template<typename T>
void print(vector<T>& v) // this is the (only) function seen by users
{
        cout << "{\n";
        for (const T& val : v)
                cout << " " << val << '\n';
        cout << '}';
}
```

## How many ways we can pass argument?

```cpp
void test(vector<int> v, vector<int>& rv)          // v is passed by value; rv is passed by reference
{
        v[1] = 99;          // modify v (a local variable)
        rv[2] = 66;         // modify whatever rv refers to
}

int main()
{
        vector fib = {1, 2, 3, 5, 8, 13, 21};
        test(fib,fib);
        cout << fib[1] <<'' << fib[2] << '\n';           // prints 2 66
}
```

## When to pass by value or by reference?
1. When we care about performance, we usually pass small values by-value and larger ones by-reference.
2. Here “small” means “something that’s really cheap to copy.” Exactly what “small” means depends on machine architecture
3. but “the size of two or three pointers or less” is a good rule of thumb. ”

## Memory error
1. try to not create pointer for stack variable, prefer to use reference.
2. Don't create pointer of varaible in stack and use that in shared pointer (don't do it)
3. std::unique_ptr(can_take_existing_ptr)

## Is CPP supports default function argument?
* yes!
``` “void print(int value, int base =10);   // print value in base "base”```

## When not to return pointer or reference to a variable?

* a local variable disappears when the function returns, so we should not return a pointer or reference to it:
* Compiler would generally catch below error
```cpp
	int& bad(){
		int x;
		// ...
		return x;  // bad: return a reference to the local variable x
	}
```

## Auto function return type deduction pros and cons
1. This can be convenient
2. Especially for generic functions (§7.3.1) and lambdas (§7.3.3),
3. but should be used carefully because a deduced type does not offer a stable interface:
4. A change to the implementation of the function (or lambda) can change its type.
5. auto mean “the return type will be mentioned later or be deduced.”
6. auto mul(int i, double d) -> double { return i*d; }         // the return type is "double”

## Structured Binding
1. “A function can return only a single value, but that value can be a class object with many members. This allows us to elegantly return many values.”


## Function
1. Function can't be invoked uless it was already declared
1. ```cpp
    [[attributes]] ReturnType FuncName(ArgumentList...) {
      // Some awesome code here.
      return return_value; 
    }
```
1. When function returns void, it is called sub-routine or procedure
1. ARTD - Automated return type deduction
```cpp
auto GetDictionary() {
  return std:map<char, int>{{'a',2}, {'b',7}};
}
```

## Function to return multiple values using tuple > 17
```cpp
#<tuple>
auto GetDictionary() {
  return make_tuple("string", 14);
}
int main() {
  auto [name, value] = GetDictionary();
  cout << name << value << endl;
  return 0;
}
```

## Why most of addresses are shown in 12digit hexa decimal?
1. In most of the systems, only the lower 48 bits (48 bits will have 12 hexadecimal digit) (or even fewer) are used for addressing, while the higher bits are either reserved or fixed.
1. With 48 bits, it could address nearly 262,144 GB of space (217 TB)
1. Rarely even if they use 64bit, leadingzeros are not shown
2. 0x56330247ce70 - How come it shows 12 digit hexa decimal? shouldn't be just 8 digit hexadecimal on64 bit computer?

## In C++, is object names are constant?
* An object name is like a constant, which cannot be reassigned with a new object?

## Copy ellision

## Move constructor

## [Generic programming or Template Programming or Meta-Programming](https://www.ipb.uni-bonn.de/html/teaching/modern-cpp/slides/lecture_9.pdf)
1. 
    ```cpp
      Cup<T>
      Cup<Cofee>
    ```
2. Iterator is also part of Generic programming
3. Writing programming that manipulate other or same programs as if they were data - Anders Hejlsberg

## C++ Definitions of template
1. Family of classes
2. Family of functions

## Example programming challenge without templates
1. max(double, double)
2. max(int, int)
3. max(float,float)
4. abs, labs, llabc=s, fabs, fabsl

## Template keywords
1. Classes templates are not classes. They are templates for making classes
2. Don’t pay for what you don’t use: If nobody calls MyClass<int>, it won’t be instantiated by the compiler at all.
3. Template Parameters - Think the template parameters the same way as any function arguemnents, but at compile-time.
4. Every template is parameterized by one or more template parameters: template < parameter-list > declaration
5. Type deduction for function templates might mislead us to believe some of function calls are not template functions? (It is!) 

## Function Templates
```cpp
template <typename T>
T abs(T x) {
  return (x>=0) ? x : -x;
}
```
1. Function templates are not functions
2. If nobody calls abs<int>, it won't be instantiated by the compiler at all.   

## Function Template sample code
```cpp
template <typename T>
void Foo() {}
int main() {
  Foo<int>(); //comment and check in compiler explorer
  Foo<double>(); //comment and check in compiler explorer
}
```

## Templates Multiple types
```cpp
template <typename T, typename S>
T awesome_function(const T& var_t, const S& var_s) {
  T result = var_t;
  return result;
}
```

## Templates can have number or default arg
```cpp
template <typename T, size_t N = 10> T
AccumulateVector(const T& val) {
  std::vector<T> vec(val, N);
  return std::accumulate(vec.begin(), vec.end(), 0);
}
using namespace std;
int main() {
  cout << AccumulateVector(1) << endl;
  cout << AccumulateVector <float >(2) << endl;
  cout << AccumulateVector<float, 5>(2.0) << endl;
  return 0;
}
```

## Usage of template keyword in invoking method

```cpp
#include <iostream>
#include <string>

template <typename T>
class MyClass {
public:
    template <typename U>
    void myMethod(U arg) {
        std::cout << "Value: " << arg << std::endl;
    }
};

int main() {
    MyClass<int> obj;
    obj.template myMethod<int>(10);        // Accessing template method with int
    obj.template myMethod<double>(3.14);      // Accessing template method with double
    obj.template myMethod<std::string>("Mohan");   // Accessing template method with std::string
    obj.template myMethod<const char*>("Hello");     // Accessing template method with const char*
    return 0;
}
```

## why are we separating template parameters here:
```cpp
template<typename Host> template<typename T, typename F>
template<typename Host> template<typename T, typename F> void Sink<Host>::doSomething(T const& msg, F next) {
//block
}
```
1. It supposed to mean, class Sink takes a template parameter Host, while Sink::do_something take 2 template parameters

## Template usage in using
```
template <typename Handler> using Service = std::shared_ptr<Service<Handler>>;
```
1. C++ is not whitespace or layout sensitive


## Define function that can be called only on LValue or RValue?

```
#include <iostream>

class Example {
public:
    void onlyLvalue() & {
        std::cout << "This function can only be called on an lvalue." << std::endl;
    }

    void onlyRvalue() && {
        std::cout << "This function can only be called on an rvalue." << std::endl;
    }
};

int main() {
    Example e;

    e.onlyLvalue(); // OK, e is an lvalue
    // Example().onlyLvalue(); // Error, temporary object is an rvalue

    // e.onlyRvalue(); // Error, e is an lvalue
    Example().onlyRvalue(); // OK, temporary object is an rvalue

    return 0;
}
```

## LValue and RValue
1. Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.
2. ```int const r& = 10;```
3. C++ cannot bind a non-const lvalue reference to a temporary object (or rvalue).
   1. ```int& r=10;```  //will fails to compile
5. The expression 10 is a temporary int, and only a const int& can bind to a temporary object.
   1. ```const int& r = 10;```


## What is template function?
1. A template function in C++ is a special kind of function that allows you to write generic and reusable code.
2. Instead of writing separate functions for different data types, you can use a template to define a single function that works with any type.
```cpp
#include <iostream>
template<typename T, std::size_t N>
constexpr std::size_t size(const T(&arr)[N]) noexcept
{
	return N;
}
int main()
{
	constexpr int a[]{ 5,4,3,2,1 };
	std::cout << size(a) << '\n';
	return 0;
}
```

## TODO 
1. [Tag dispatching](https://www.fluentcpp.com/2018/04/27/tag-dispatching/)
1. [Tag vs ENum](https://www.fluentcpp.com/2018/05/01/when-to-use-enums-and-when-to-use-tag-dispatching-in-cpp/)
2. [Ranges](https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/)
3. [Julian Templeman on Templates](https://learning.oreilly.com/course/diving-deeper-into/9781491988701/)
4. [Julian Templeman on Templates](https://learning.oreilly.com/course/further-exploration-of/9781491988732/)
5. [31 nooby C++ habits you need to ditch ](https://www.youtube.com/watch?v=i_wDa2AS_8w)
6. 


## Reference
1. [cpp.sh](https://cpp.sh)
2. [https://ideone](https://ideone.com/HmZVro](https://ideone.com/HmZVro)
3. [Operator Precedence](https://en.cppreference.com/w/cpp/language/operator_precedence)

## Generate MdAnki
```bash
mdanki cpp.md cpp.apkg --deck "Mohan::DeepWork::cpp"
```
