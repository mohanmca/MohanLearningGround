## Simple Binary Encoding
1. Class generated by SbeTool (we call them Flyweight)
2. SBE flyweights behaves a bit like a stencil, you position it over a wall (byte array) at the right place (offset) and then you can paint (encode) very quickly!


## Order of encoding
1. Within the fields section, fields are encoded in the order specified by schema.
2. Then repeating groups, again in the order specified in the schema.
3. Finally variable length fields, in the order specified by the schema.
4. Developer encode and decode in the order specified by the schema. Failing to do so could at best reduce performance, at worst return invalid data during decoding or corrupt data in the buffer during encoding.
5. API might let encode and decode out of order. But there are plans to improve that and throw errors if detected an invalid sequence
6. That constraint helps simplifying the flyweight design and make it more hardware friendly.

## SBE Flyweights vs DTO
1. SBE does not work with DTO: the flyweight writes directly to the underlying buffer during encoding and reads directly from the buffer during decoding.
2. When we write orderId = 72 in the order flyweight, what it does is encode 72 in its byte representation (which depends of the orderId primitive type and of the endianess) and store it directly in the underlying buffer.
3. Flyweights can be reused indefinitely, to encode and decode different messages.But it is not threadsafe
4. When you decode a field of one of the primitive types, nothing is allocated, itâ€™s only a stack operation.

## How to decode array?
1. when you decode a field of type array you do not get a new array allocated and given back you:
2. Provide your own buffer (that you can reuse on your side) and the flyweight will copy data to your buffer.
3. Again, this allows your system to not allocate.
   4. Why limiting or preventing allocation? To limit or suppress GCs, which will slow down your encoding and decoding operations

## Google Protocol Buffer vs SBE
1. SBE is significantly faster, but there is a more subtle aspect:
2. GPB allocates so it will trigger GCs and slow down the overall system. This is another big advantage for SBE.

## Fast array access
1. Reading integers of different sizes from a byte array in C++ is simple:  apply an offset to your byte pointer, cast the pointer to the type you need and dereference, job done. 
2. To work around those (performance) limitations Java uses the Unsafe class, which basically perform pointer operations under the hood and gets inlined (resulting in the same assembly code than C++)

## How to access different size of integers in C++

```cpp
#include <iostream>
#include <cstdint>

int main() {
    // Example byte array (could be filled with data from a file, network, etc.)
    uint8_t byteArray[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    
    // Pointer to the beginning of the array
    uint8_t* ptr = byteArray;
    
    // Read an 8-bit integer (1 byte)
    uint8_t value8 = *reinterpret_cast<uint8_t*>(ptr);
    std::cout << "8-bit value: " << static_cast<uint32_t>(value8) << std::endl;
    
    // Advance the pointer by 1 byte to read the next value
    ptr += sizeof(uint8_t);
    
    // Read a 16-bit integer (2 bytes)
    uint16_t value16 = *reinterpret_cast<uint16_t*>(ptr);
    std::cout << "16-bit value: " << value16 << std::endl;
    
    // Advance the pointer by 2 bytes to read the next value
    ptr += sizeof(uint16_t);
    
    // Read a 32-bit integer (4 bytes)
    uint32_t value32 = *reinterpret_cast<uint32_t*>(ptr);
    std::cout << "32-bit value: " << value32 << std::endl;

    return 0;
}
```

## Endianess
1. Endianess specifies the order bytes are stored for a given primitive type. Most hardware use little endian and network historically use big endian.
2. In little-endian format, the least significant byte (LSB) is stored at the smallest memory address, and the most significant byte (MSB) is stored at the largest.
3. C++ uses a macro to apply endianess, which compiles to a single x86 instruction bswap.
4. The bswap instruction on x86 architectures is a highly efficient way to swap the byte order of a 16-bit, 32-bit, or 64-bit integer, converting it between little-endian and big-endian formats.
5. Java uses integer.reverse, which gets optimized away as well as bswap.


## Reference
1. [Design principles for SBE, the ultra-low latency marshaling API](https://weareadaptive.com/2013/12/15/design-principles-for-sbe-the-ultra-low-latency-marshaling-api/)

## Generate Anki
```bash
mdanki SBE.md sbe.apkg --deck "Mohan::DeepWork::Encoding::SBE"
```
